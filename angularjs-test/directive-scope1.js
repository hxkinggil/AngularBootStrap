
/**
 *
 * 隔离空间和父作用域属性间的绑定
 *
 * 方法1: 使用@来进行单项文本绑定
 *
 *      我们将这种方法成为单向绑定因为使用这种方法你只可以将字符串传递到属性（使用表达式，{{}}）。
 *      当父作用域属性发生变化时，你的隔离作用域模型也发生变化。
 *      你甚至可以在指令内部监视这个作用域属性并且在变化发生时触发任务。
 *      然而，反之则不成立！你不能通过操纵隔离作用域来改变父作用域。
 *      如果隔离作用域属性和元素属性名相同你可以这样来写指令定义 （ scope: {color: '@'} )
 *
 * 方法2：使用=进行双向绑定
 *
 *      和@不一样，这种技巧让你可以将一个实际的作用域模型赋值给一个属性而不是一个普通的字符串。
 *      结果是你可以传递将简单地字符串到复杂的数组传递到隔离作用域。
 *      同时，一个双向绑定被建立了。
 *      无论什么时候父作用域属性发生了变化，相应的隔离作用域的属性也会发生变化，反之亦然。
 *      通常情况下，你可以监视作用域属性的变化。
 *
 * 方法3：使用&来执行父作用域中的函数
 *
 *
 *
 *
 * 下列的指导原则可能会帮助你为你的指令选择正确的作用域。
 *
 *    1.父作用域（scope: false）-
 *       这是默认情况下的选择。如果你的指令不需要找父作用域属性你可能不需要一个新的作用域。
 *       在这种情形中，使用父作用域是没问题的。
 *
 *    2.子作用域（scope: true）-
 *       这为一个指令创建了一个原型继承于父作用域的子作用域。
 *       如果你在作用域中设置的属性和函数与其他的指令和父作用域没什么联系，你应该创建一个新的子作用域。
 *       这样一来你也拥有了在父作用域中定义的所有作用域属性和函数。
 *
 *    3.隔离作用域（scope:{}）-
 *       这像是一个沙盒！如果你创建的指令是自包含并且可重用的你需要这种作用域。
 *       你的指令可能会创建许多作用域属性和函数用于内部使用，并且永远不应该被外界看到。
 *       如果你处于这种情况下，最好使用一个隔离作用域。正如你所期望的，隔离作用域并不会继承父作用域。
 *
 *
 * Created by gc on 2014/8/19.
 *
 */
var directiveScopeModule = angular.module('app', []);

directiveScopeModule.directive('helloWorld',function(){
    return {
        /**
        //方法1：
        scope: {
            color: '@'
        },*/
        //方法2：
        scope: {
            color: '='
        },
        restrict: 'AE',
        replace: true,
        template: '<p style="background-color:{{color}}">Hello World{{color}}</p>',
        link: function(scope,elem,attrs){
            elem.bind('click',function(){
                elem.css('background-color','white');
                scope.$apply(function(){
                    scope.color = "white";
                });
            });
            elem.bind('mousover',function(){
                elem.css('cusor','pointer');
            });
        }
    }
});